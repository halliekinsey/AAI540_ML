# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GhGHAojValq6NSS4GAgN3h8TSSMV3_Ws
"""

pip install requests python-dotenv

import os
API_BASE = "https://api.cloud.llamaindex.ai/api"  # base URL for LlamaParse API
API_KEY = os.getenv("llx-8sJfZqwIFgzI59ngwMZ5alCa92atXXMMnLINuwU468jkYvcN")

#Parse a local PDF File:
#python llama_parse_script.py --file path/to/document.pdf

#Parse a PDF by URL:
#python llama_parse_script.py --url https://example.com/sample.pdf

#Restrieve a stored result:
#python llama_parse_script.py --retrieve <document_id>

import os
import sys
import time
import argparse
import requests
from dotenv import load_dotenv

# Load environment variables from .env file, if available
load_dotenv()

# Set your API key directly for testing (or use an environment variable)
API_KEY = "llx-8sJfZqwIFgzI59ngwMZ5alCa92atXXMMnLINuwU468jkYvcN"
if not API_KEY:
    raise RuntimeError("API key not found. Please set LLAMA_CLOUD_API_KEY.")

# Base URL for LlamaParse API (v1 endpoints)
API_BASE = "https://api.cloud.llamaindex.ai/api"
UPLOAD_ENDPOINT = f"{API_BASE}/parsing/upload"
JOB_STATUS_ENDPOINT = f"{API_BASE}/parsing/job"
RESULT_ENDPOINT = f"{API_BASE}/parsing/job"

# Directory to store parsed markdown files
STORAGE_DIR = "parsed_docs"
os.makedirs(STORAGE_DIR, exist_ok=True)

def submit_file_to_llamaparse(file_path):
    """
    Upload a PDF file to LlamaParse for parsing in accurate mode.
    Returns the job_id.
    """
    with open(file_path, "rb") as f:
        files = {"file": (os.path.basename(file_path), f, "application/pdf")}
        # Use accurate mode instead of premium mode
        data = {"accurate_mode": "true"}
        headers = {"Authorization": f"Bearer {API_KEY}"}
        response = requests.post(UPLOAD_ENDPOINT, headers=headers, files=files, data=data)
    response.raise_for_status()  # raise exception if request failed
    result = response.json()
    job_id = result.get("job_id") or result.get("id")
    if not job_id:
        raise RuntimeError("No job_id returned from LlamaParse API.")
    print(f"Submitted file for parsing. Job ID: {job_id}")
    return job_id

def submit_url_to_llamaparse(file_url):
    """
    Submit a URL to LlamaParse for parsing in accurate mode.
    Returns the job_id.
    """
    data = {"input_url": file_url, "accurate_mode": "true"}
    headers = {"Authorization": f"Bearer {API_KEY}"}
    response = requests.post(UPLOAD_ENDPOINT, headers=headers, data=data)
    response.raise_for_status()
    result = response.json()
    job_id = result.get("job_id") or result.get("id")
    if not job_id:
        raise RuntimeError("No job_id returned from LlamaParse API.")
    print(f"Submitted URL for parsing. Job ID: {job_id}")
    return job_id

def check_job_status(job_id):
    """
    Check the parsing job status from LlamaParse API.
    Returns the status string.
    """
    headers = {"Authorization": f"Bearer {API_KEY}"}
    url = f"{JOB_STATUS_ENDPOINT}/{job_id}"
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    status = resp.json().get("status", "")
    return status

def retrieve_markdown_result(job_id):
    """Retrieve the parsed markdown result for a completed job."""
    headers = {"Authorization": f"Bearer {API_KEY}"}
    url = f"{RESULT_ENDPOINT}/{job_id}/result/markdown"
    resp = requests.get(url, headers=headers)
    resp.raise_for_status()
    result_json = resp.json()

    # Debug: Print the full API response to inspect its structure
    print("DEBUG: API response:", result_json)

    # Try to extract the markdown from common keys
    md_content = result_json.get("result") or result_json.get("data") or result_json.get("markdown") or ""

    # Some API versions might return the markdown directly as text.
    if isinstance(result_json, str) and result_json.strip().startswith("#"):
        md_content = result_json
    if not md_content:
        raise RuntimeError("Markdown result not found in API response.")
    return md_content


def save_markdown(job_id, markdown_text):
    """
    Save the markdown text to a file in the storage directory.
    """
    filename = os.path.join(STORAGE_DIR, f"{job_id}.md")
    with open(filename, "w", encoding="utf-8") as f:
        f.write(markdown_text)
    return filename

def load_markdown(job_id):
    """
    Load markdown text from a saved file by job_id (for retrieval).
    """
    filename = os.path.join(STORAGE_DIR, f"{job_id}.md")
    if not os.path.isfile(filename):
        raise FileNotFoundError(f"No stored file found for job ID {job_id}.")
    with open(filename, "r", encoding="utf-8") as f:
        content = f.read()
    return content

if __name__ == "__main__":
    # If running in a notebook environment, you might simulate command-line arguments:
    # Uncomment the following line and adjust the argument as needed:
    # sys.argv = ["script.py", "--file", "your_document.pdf"]

    import sys
    sys.argv = ["script.py", "--file", "W-2_W-3.pdf"]

    parser = argparse.ArgumentParser(description="Parse PDF documents using LlamaParse API in Accurate Mode.")
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("--file", help="Path to PDF file to parse")
    group.add_argument("--url", help="URL of PDF file to parse")
    group.add_argument("--retrieve", help="Job ID of a previously parsed document to retrieve")
    args = parser.parse_args()

    if args.file:
        # 1. Submit file for parsing
        job_id = submit_file_to_llamaparse(args.file)
        # 2. Poll job status until complete
        print("Parsing in progress, waiting for completion...")
        start_time = time.time()
        while time.time() - start_time < 600:  # increased timeout to 600 seconds
            status = check_job_status(job_id)
            print(f"Job {job_id} status: {status}")  # Debug: print current status
            if status.lower() in ("completed", "done", "success"):
                break
            elif status.lower() in ("failed", "error"):
                raise RuntimeError(f"Parsing job failed with status: {status}")
            time.sleep(2)
        else:
            raise TimeoutError("Parsing job did not complete within 600 seconds.")
        print("Parsing completed. Fetching results...")
        # 3. Retrieve markdown result
        markdown = retrieve_markdown_result(job_id)
        # 4. Save to file
        output_file = save_markdown(job_id, markdown)
        print(f"✅ Document parsed successfully! Saved output to '{output_file}'.")
        print("You can run this script with --retrieve {job_id} to view the content, or open the file in a Markdown viewer.")

    elif args.url:
        # Same steps as file, but for URL input
        job_id = submit_url_to_llamaparse(args.url)
        print("Parsing in progress, waiting for completion...")
        start_time = time.time()
        while time.time() - start_time < 600:  # wait up to 600 seconds
            status = check_job_status(job_id)
            print(f"Job {job_id} status: {status}")
            if status.lower() in ("completed", "done", "success"):
                break
            elif status.lower() in ("failed", "error"):
                raise RuntimeError(f"Parsing job failed with status: {status}")
            time.sleep(2)
        else:
            raise TimeoutError("Parsing job did not complete within 600 seconds.")
        print("Parsing completed. Fetching results...")
        markdown = retrieve_markdown_result(job_id)
        output_file = save_markdown(job_id, markdown)
        print(f"✅ Document parsed successfully! Saved output to '{output_file}'.")
        print(f"Use the job ID '{job_id}' with --retrieve to get the content later, or open the Markdown file directly.")

    elif args.retrieve:
        # Retrieve stored markdown by job ID
        try:
            content = load_markdown(args.retrieve)
        except FileNotFoundError:
            print(f"No parsed document found for ID '{args.retrieve}'. Make sure the ID is correct and parsing was done earlier.")
        else:
            print(f"** Markdown content for job {args.retrieve}: **\n")
            print(content)